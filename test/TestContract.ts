import BigNumber from 'bignumber.js';
import Web3, { ContractInstance } from 'web3';
import FakeProvider from 'web3-fake-provider';

import { DeferredTransactionWrapper, ITxParams, TypeChainContract } from '../types';

import { AbiDefinition } from '@0xproject/types';

const validateExpected = (args: any[], expectedArgs: any[]) => {
  for (let i = 0; i < expectedArgs.length; i++) {
    if (expectedArgs[i] instanceof Array) {
      validateExpected(args[i], expectedArgs[i]);
    } else if (typeof expectedArgs[i] === 'number' || expectedArgs[i] instanceof BigNumber) {
      expect(args[i]).toEqual(expectedArgs[i].toString());
    } else {
      expect(args[i]).toEqual(expectedArgs[i]);
    }
  }
};

/**
 * Provides a harness to test autogenerated contract types
 */
export class TestContract<T extends TypeChainContract> {
  private readonly mockWeb3: Web3;
  private readonly mockWeb3Contract: ContractInstance;

  constructor(contractName: string, private address: string, contractCode?: string) {
    this.mockWeb3 = new Web3(new FakeProvider());

    this.mockWeb3Contract = {
      address: address,
      abi: require(`../node_modules/@marketprotocol/marketprotocol/build/contracts/${contractName}.json`)
    };

    spyOn(this.mockWeb3.eth, 'getCode').and.callFake(
      (addr: string, cb: (err: Error | null, code: string) => void) => {
        expect(addr).toEqual(address);
        cb(null, contractCode || '0x234');
      }
    );

    this.setupMockContract(this.mockWeb3, this.mockWeb3Contract);
  }

  /**
   * Creates an instance of the contract type
   *
   * @param createMethod The create method of the contract type
   */
  public async createContract(
    createMethod: (web3: any, address: string | BigNumber) => Promise<T>
  ) {
    return createMethod(this.mockWeb3, this.address);
  }

  /**
   * Mocks out a web3 method
   *
   * @param methodName The method to mock out
   * @param expectedOrError The expected error or return value
   * @param expectedArgs The expected arguments
   */
  public setupMethodSpy(methodName: string, expectedOrError: Error | any, ...expectedArgs: any[]) {
    const expected = expectedOrError instanceof Error ? null : expectedOrError;
    const expectedError = expectedOrError instanceof Error ? expectedOrError : null;

    this.mockWeb3Contract[methodName] = this.createMethodSpy(expectedArgs, expected, expectedError);
  }

  /**
   * Mocks out a web3 getter method
   *
   * @param methodName The method to mock out
   * @param expected The expected return value
   */
  public setupGetterSpy(methodName: string, expected: any) {
    this.mockWeb3Contract[methodName] = this.createMethodSpy([], expected);
  }

  /**
   * Mocks out a web3 transactional method
   *
   * @param methodName The method to mock out
   * @param txArgs The expected transaction args
   * @param expectedArgs The expected arguments
   */
  public setupTxMethodSpy(methodName: string, txArgs?: ITxParams, ...expectedArgs: any[]) {
    const web3MethodName = methodName.slice(0, methodName.length - 2);
    const expectedData = '0x128782984';

    txArgs = txArgs || {
      from: '0x237893629'
    };

    this.mockWeb3Contract[web3MethodName] = {
      sendTransaction: this.createMethodSpy(expectedArgs.concat(txArgs)),
      getData: jasmine.createSpy().and.callFake((...args) => {
        validateExpected(args, expectedArgs);
        return expectedData;
      })
    };
  }

  public setupEventSpy(eventName: string, expectedArgs: any[], expected?: any, error?: any) {
    this.mockWeb3Contract[eventName] = (...args) => {
      validateExpected(args, expectedArgs);
      return {
        watch: jasmine.createSpy().and.callFake(cb => {
          cb(error, expected);
        }),
        stopWatching: this.createMethodSpy([])
      };
    };
  }

  public async assertEvent<N>(method: Promise<N>, expected?: any) {
    const result = await method;

    expect(result).toEqual(expected);
  }

  /**
   * Tests the specified method and ensures the method returns the correct value
   *
   * @param method A reference to the method to test
   * @param expectedOrError The expected error or return value
   */
  public async assertMethod<N>(method: Promise<N>, expectedOrError?: Error | N) {
    try {
      const result = await method;

      if (expectedOrError instanceof Error) {
        fail();
      } else {
        expect(result).toBe(expectedOrError);
      }
    } catch (e) {
      if (expectedOrError instanceof Error) {
        expect(e).toBe(expectedOrError);
      } else {
        fail();
      }
    }
  }

  /**
   * Tests the specified transactional method and ensures the method returns the correct value
   *
   * @param method A reference to the method to test
   * @param txArgs The transaction params
   * @param expected The expected return value
   */
  public async assertTxMethod(
    method: DeferredTransactionWrapper<ITxParams>,
    txArgs: ITxParams,
    expected?: any
  ) {
    const txResult = await method.send(txArgs);
    expect(txResult).toBe(expected);

    const txResultCustomWeb3 = await method.send(txArgs, this.mockWeb3);
    expect(txResultCustomWeb3).toBe(expected);

    const expectedData = '0x128782984';
    const dataResult = await method.getData();
    expect(dataResult).toBe(expectedData);
  }

  /**
   * Sets up the web3 instance to return the specified contract instance when web3.eth.contract().at() is called
   *
   * @param web3 The web3 instance to spy on
   * @param web3Contract The web3 contract to return
   */
  private setupMockContract(web3: Web3, web3Contract: ContractInstance) {
    spyOn(web3.eth, 'contract')
      .and.callFake((abi: AbiDefinition[]) => {
        expect(abi).toEqual(web3Contract.abi);
      })
      .and.returnValue({
        at: (addr: string) => {
          expect(addr).toEqual(this.address);
          return web3Contract;
        }
      });
  }

  private createMethodSpy(expectedArgs: any[], expected?: any, error?: any) {
    return jasmine.createSpy().and.callFake((...args) => {
      validateExpected(args, expectedArgs);
      const cb = args[args.length - 1];
      cb(error, expected);
    });
  }
}
